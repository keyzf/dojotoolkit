dojo.provide("dojox.xmpp.SaxToJson");

dojo.require("dojox.xml.SaxParser");
dojo.require("dojox.string.Builder");

dojo.declare("dojox.xmpp.SaxToJson", [], {
    // summary:
    //      A SAX stream reader for xmpp stream which reads the stream form
    //      SAX parser and converts the xmpp stanzas (level 1 packets) to json

    // Events raised to be consumed by users
    onSessionStart: function() {},
    onSessionEnd: function() {},
    onStanza: function(stanzaNode) {},

    constructor: function() {
        // summary:
        //      Initialise the SAX parser

        this._saxParser = new dojox.xml.SaxParser(true);
        this._saxDepth = 0;
        this._nodeStack = new Array();
        this._cDataStack = new Array();

        this._attachHandlers();
    },

    _attachHandlers: function(){
        // summary:
        //      Attach handlers for events raised by SAX stream reader

        // Detach old handlers
        if(this._startElementConnectHandle) dojo.disconnect(this._startElementConnectHandle);
        if(this._endElementConnectHandle) dojo.disconnect(this._endElementConnectHandle);
        if(this._charactersConnectHandle) dojo.disconnect(this._charactersConnectHandle);

        // Attach handlers
        this._startElementConnectHandle = dojo.connect(this._saxParser, "onStartElement", this, "_startElementHandler");
        this._endElementConnectHandle = dojo.connect(this._saxParser, "onEndElement", this, "_endElementHandler");
        this._charactersConnectHandle = dojo.connect(this._saxParser, "onCdataCharacters", this, "_charactersHandler");
    },

    _startElementHandler: function(/*String*/ nodeName, /*String*/ attributes){
        // summary:
        //      Fired at the start of the xml element in the
        //      xmpp stream

        this._saxDepth++;
        var jsonData = this._attrToJson(nodeName, attributes);
        this._nodeStack.push(jsonData);
        var cData = new dojox.string.Builder();
        this._cDataStack.push(cData);
    },

    _charactersHandler: function(/*String*/ chars){
        // sunmary:
        //      Raised when text for an xml element received

        // Instead of pop-push, modify Array[length-1] element
        var len = this._cDataStack.length;
        if(len == 0){
            console.error("Incorrect SAX stream, stray character data received");
        }
        else{
            this._cDataStack[len-1].append(chars);
        }
    },

    _endElementHandler: function(/*String*/ nodeName){
        // summary:
        //      Fired at the end of the xml element in the
        //      xmpp stream

        this._saxDepth--;
        var node = this._nodeStack.pop();
        var text = this._cDataStack.pop().toString();
        node["#text"] = text;

        // Add child node to parent
        var len = this._nodeStack.length;
        if(len>0){
            this._nodeStack[len-1][nodeName] = node;
        }

        if (this._saxDepth == 1){
            if(nodeName != "vCard"){
                console.warn(node)
            }
            var result = {};
            result[nodeName] = node;
            this.onStanza(result);
        }
        else{
            if (this._saxDepth == 0){
                this.onSessionEnd();
            }
        }
    },

    _attrToJson: function(/*String*/ nodeName, /*String*/ attrList){
        // summary:
        //      Convert the attributes list from SAX parser into a JSON


        attrList = attrList.split(/ /);
        var attr = null;
        var jsonData = {};
        var len = attrList.length;
        var i;

        // Preprocess the list to remove empty strings generated by continuous spaces
        var altList = [];
        var cur = "";
        for(i=0; i<len; i++){
            if(attrList[i].length == 0)
                cur += " ";
            else
                cur = attrList[i];
            altList.push(cur);
        }
        attrList = altList;

        // This will silenlently ignore the attributes not matching the regex
        for(i=0; i<len; i++){
            attr = attrList[i];

            var match = attr.match(/\s*(\S+)\s*=\s*\"([\s\S]*)\"\s*/);
            if(match){
                attr = null;
                jsonData["@" + match[1]] = match[2];
            }
            else{
                match = attr.match(/\s*(\S+)\s*=\s*\'([\s\S]*)\'\s*/);
                if (match){
                    attr = null;
                    jsonData["@" + match[1]] = match[2];
                }
            }
        }
        return jsonData;
    },

    parse: function(data) {
        // summary:
        //      Route the stream data received to SAX parser

        this._saxParser.parse(data);
    }
});
